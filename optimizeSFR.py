#   OptimizeSFR.py
#   Python set of functions to optimize the elevation of
#   streambed for SFR and a given MODFLOW grid.
#   The idea is that the streambed must be routed-
#   the next reach has either lower elevation or same elevation.
#   The elevation assigned to each reach should be consistent
#   with the top of the MODFLOW grid cell:  the stream should
#   not float above the surface and it shouldn't be too incised.
#   But, because it is very difficult to have these conditions
#   everywhere, we seek an optimal solution where the
#   streams are routed and the floating or high-incision is
#   minimized.
#
#   Stream elevations are derived from the Maxsmoothelev, Minsmoothelev
#   attributes in NHDPlus - these are for COMIDs which are translated
#   to SFR segments.  The segments are broken into reaches by intesecting
#   them with the MODFLOW grid.  The initial guess for SFR elevation
#   is generated by linear interpolation down the segment by stream
#   length- the initial guess is routed.
#
#   author: H.W. Reeves, USGS Michigan Water Science Center
#   date: October 1, 2012
#   
import os
import re
import numpy as np
from scipy.sparse import coo_matrix
from scipy.io import mmwrite
import math
from collections import defaultdict


def FloatInciseFunction(weight_float,weight_incise,fact_float,fact_incise,power,sfrelev,gridelev):
    '''
    function to test for floating and incised reaches
    uses weighting factors to generate a value that will
    be minimized in the optimization
    
    weight_float = weighting factor for floating reach
    weight_incise = weighting factor for incised reaches
    fact_float = allowable error for floating reaches (should be negative or zero)
    fact_incise = maximum desired incision before penalty is added
    power = power to raise difference, higher gives more weight to larger differences
    sfrelev = input elevations for SFR reaches, dictionary by cell number
    gridelev = elevations of grid cells, dictionary by cell number

    returns vector of values by cell number and function total
    '''

    function=0.
    diff=dict()
    for cellnum in sfrelev.iterkeys():
        difference=gridelev[cellnum]-sfrelev[cellnum]
        if difference<fact_float:
            diff[cellnum]=difference
            function=function+weight_float*math.pow(difference,power)
        elif difference>fact_incise:
            diff[cellnum]=difference
            function=function+weight_incise*math.pow(difference,power)
        else:
            diff[cellnum]=difference

    return (function, diff)
            

def BuildConnectionMatrix(SEGfilein,RCHfilein):
    '''
    function to build the connectivity matrix for SFR reaches, used in the constraint
    equation  Ax >= 0  where x is a vector of SFR elevations.  The matrix A has a value
    1 designating the reach and -1 designating the next downstream reach for
    every connection.  The equations are  SFR(upstream) - SFR(downstream) >= 0
    for every connection in the stream network represented by SFR.

    The matrix is sparse, so the sparse matrix packages in scipy are used and
    the function returns the matrix in COOrdinate format.

    The segment and reach files generated in the routines to build SFR from NHDPlus
    and a grid are used to give the connection information, and the sparse
    matrix A, dictionary linking [segment][reach] to reach index, and dictionary
    linking reach index to [segment][reach] are returned.
    '''
    #need to make array of reaches and link to segment-reach numbering
    #allreach-> dictionary of over reach index keyed by [segment][reach]
    #invallreach-> dictionary that gives (segment,reach) for each overall reach index
    allreach=defaultdict(dict)
    invallreach=dict()
    
    #read information from files
    RCH=open(RCHfilein,'r')
    header=RCH.readline()
    rchindex=0
    for line in RCH:
        vals=re.split(',',line)
        segment=int(vals[6])
        reach=int(vals[5])
        allreach[segment][reach]=rchindex
        invallreach[rchindex]=(segment,reach)
        rchindex+=1
    RCH.close()
    numreaches=rchindex

    #segment connection information
    #inletsegments dictionary has segment as key and next segment as value
    #outletsegments dictionary has next segment as key and segment as value
    #headwaters do not appear in outletsegments

    SEG=open(SEGfilein,'r')
    header=SEG.readline()
    outletsegments=dict()
    inletsegments=dict()
    numsegments=0
    for line in SEG:
        vals=re.split(',',line)
        segment=int(vals[0])
        outsegment=int(vals[2])
        outletsegments[outsegment]=segment
        inletsegments[segment]=outsegment
        numsegments+=1
    SEG.close()
        
    #vectors to build sparse matrix in COO format
    datavector=[]
    ivector=[]
    jvector=[]

    for indx in range(0,numreaches):
        (segment,reach)=invallreach[indx]
        sortedreaches=sorted(allreach[segment].iterkeys())
        if reach==sortedreaches[-1]:
            nextsegment=inletsegments[segment]
            nextreach=1
        else:
            nextsegment=segment
            nextreach=reach+1
        if nextsegment==0:
            #downstream segment, just put 1 in the reach diagonal
            datavector.append(1)
            ivector.append(indx)
            jvector.append(indx)
        else:
            #put 1 in reach column and -1 in nextreach column
            datavector.append(1)
            ivector.append(indx)
            jvector.append(indx)
            datavector.append(-1)
            ivector.append(indx)
            jvector.append(allreach[nextsegment][nextreach])
    SEG.close()
    connect=coo_matrix((np.array(datavector), (np.array(ivector),np.array(jvector))),
                       shape=(numreaches,numreaches),dtype=np.int8)
        
    return (connect,allreach,invallreach)

#
#  MAIN PROGRAM
#

if __name__ == '__main__':
    #hard code filenames
    #GWVSHP='gwv_elev_exp.shp'
    RCHin='SFRmat1A.txt'
    SEGin='SFRmat2A.txt'
    TOPNEW=open('TOPNEW-2.MAT','r')
    #set rows and columns
    nrow=600
    ncol=740
    #set maximum incision
    maxincise=50.
    #set maximum floating, use negative to indicate above land surface
    maxfloating=-1.0

    #set up some vectors to hold SFR and grid info
    gwv=dict()
    sfrtop=dict()

    #build connectivity matrix
    (connect,allreach,invallreach)=BuildConnectionMatrix(SEGin,RCHin)
    #mmwrite('check.mtx',connect)
    
    #read in elevations and put into array ordered by overall index
    RCH=open(RCHin,'r')
    header=RCH.readline()
    numreaches=len(invallreach)
    sfrvector=np.zeros((numreaches,1),dtype=np.float)
    invcellnum=defaultdict(dict)
    segment=dict()
    reach=dict()
    seensegs=dict()
    for line in RCH:
        vals=re.split(',',line)
        row=int(vals[0])
        column=int(vals[1])
        sfrelev=float(vals[4])
        cellnum=(row-1)*ncol+column
        segment[cellnum]=int(vals[6])
        seensegs[segment[cellnum]]=1
        reach[cellnum]=int(vals[5])
        indx=allreach[segment[cellnum]][reach[cellnum]]
        invcellnum[segment[cellnum]][reach[cellnum]]=cellnum
        sfrtop[cellnum]=sfrelev
        sfrvector[indx]=sfrelev
    RCH.close()

    #read cell elevation from text file exported by GWV
    gwv=dict()
    for i in range(0,nrow):
        line=TOPNEW.readline()
        vals=re.split('\s+',line.strip())
        for j in range(0,ncol):
            cellnum=(i*ncol)+(j+1)
            gwv[cellnum]=float(vals[j])

    TOPNEW.close()
   
    #multiply elevations by connectivity matrix
    residuals=connect.dot(sfrvector)

    CHK2=open('check2.out','w')
    power=2
    #check multiplication
    for seg in sorted(seensegs.iterkeys()):
        sortedreaches=sorted(allreach[seg].iterkeys())
        for i in range(0,len(sortedreaches)-1):
            cellnum=invcellnum[seg][sortedreaches[i]]
            cellnext=invcellnum[seg][sortedreaches[i+1]]
            change=sfrtop[cellnum]-sfrtop[cellnext]
            indx=allreach[seg][sortedreaches[i]]
            warn=change-residuals[indx]
            if math.fabs(warn) > 0.01:
                CHK2.write(",".join(map(str,(warn, change, residuals[indx], indx, seg, sortedreaches[i], sfrtop[cellnum])))+"\n")
    
    CHK2.write('**********  PENALTY ****************\n')
    (penalty,diff)=FloatInciseFunction(1000.,1.,maxfloating,maxincise,power,sfrtop,gwv)
    if penalty<0:
        printstring=(penalty, penalty/numreaches)
    else:
        printstring=(penalty,penalty/numreaches,math.pow(penalty,float(1./power)),math.pow(penalty,float(1./power))/numreaches)
    CHK2.write(",".join(map(str,printstring))+'\n')
    for cellnum in sfrtop.iterkeys():
        CHK2.write(",".join(map(str,(cellnum, sfrtop[cellnum], gwv[cellnum], diff[cellnum])))+'\n')


    CHK2.close()
