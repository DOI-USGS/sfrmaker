<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sfrmaker.lines &mdash; SFRmaker 0.11.1.post13.dev0+gf681dbf documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=9c7ba1cc"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SFRmaker
          </a>
              <div class="version">
                0.11.1.post13.dev0+gf681dbf
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html"> Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"> Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html"> Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../inputs.html"> Input Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"> Using SFRmaker with a configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/SFRmaker_demo.html"> Basic Usage in a scripting context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/preprocessing_demo.html"> Preprocessing NHDPlus version 2 data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/lines_from_NHDPlusHR_demo.html"> Using SFRmaker with NHDPlus High Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html"> Concepts and methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/sfrmaker_tools.html"> Stand-alone tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html"> Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html"> Code reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config-summary.html"> Summary of configuration file options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-history.html"> Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html"> Contributing to SFRmaker</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../references.html"> References cited</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SFRmaker</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sfrmaker.lines</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sfrmaker.lines</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">pyproj</span>
<span class="kn">import</span> <span class="nn">flopy</span>
<span class="kn">from</span> <span class="nn">gisutils</span> <span class="kn">import</span> <span class="n">df2shp</span><span class="p">,</span> <span class="n">get_authority_crs</span><span class="p">,</span> <span class="n">get_shapefile_crs</span>
<span class="kn">import</span> <span class="nn">sfrmaker</span>
<span class="kn">from</span> <span class="nn">sfrmaker.routing</span> <span class="kn">import</span> <span class="n">pick_toids</span><span class="p">,</span> <span class="n">find_path</span><span class="p">,</span> <span class="n">make_graph</span><span class="p">,</span> <span class="n">renumber_segments</span>
<span class="kn">from</span> <span class="nn">sfrmaker.checks</span> <span class="kn">import</span> <span class="n">routing_is_circular</span><span class="p">,</span> <span class="n">is_to_one</span>
<span class="kn">from</span> <span class="nn">sfrmaker.gis</span> <span class="kn">import</span> <span class="n">read_polygon_feature</span><span class="p">,</span> <span class="n">get_bbox</span><span class="p">,</span> <span class="n">get_crs</span>
<span class="kn">from</span> <span class="nn">sfrmaker.grid</span> <span class="kn">import</span> <span class="n">StructuredGrid</span>
<span class="kn">from</span> <span class="nn">sfrmaker.nhdplus_utils</span> <span class="kn">import</span> <span class="n">load_nhdplus_v2</span><span class="p">,</span> <span class="n">get_prj_file</span><span class="p">,</span> <span class="n">load_nhdplus_hr</span>
<span class="kn">from</span> <span class="nn">sfrmaker.sfrdata</span> <span class="kn">import</span> <span class="n">SFRData</span>
<span class="kn">from</span> <span class="nn">sfrmaker.units</span> <span class="kn">import</span> <span class="n">convert_length_units</span><span class="p">,</span> <span class="n">get_length_units</span>
<span class="kn">from</span> <span class="nn">sfrmaker.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">width_from_arbolate_sum</span><span class="p">,</span> <span class="n">arbolate_sum</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sfrmaker.reaches</span> <span class="kn">import</span> <span class="n">consolidate_reach_conductances</span><span class="p">,</span> <span class="n">interpolate_to_reaches</span><span class="p">,</span> <span class="n">setup_reach_data</span>
<span class="kn">from</span> <span class="nn">sfrmaker.routing</span> <span class="kn">import</span> <span class="n">get_previous_ids_in_subset</span>


<div class="viewcode-block" id="Lines">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines">[docs]</a>
<span class="k">class</span> <span class="nc">Lines</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for working with linestring feature input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : DataFrame or GeoDataFrame</span>
<span class="sd">        Dataframe with linestring features (flowlines) and attribute information.</span>
<span class="sd">        Column descriptions:</span>
<span class="sd">        </span>
<span class="sd">        ========================= =============================================================</span>
<span class="sd">        **id**                    Sequential integers representing each flowline</span>
<span class="sd">        **toid**                  Integers representing downstream routing connections</span>
<span class="sd">        **arbolate_sum_column2**  (optional) Arbolate sum at the end of each flowline</span>
<span class="sd">        **width1_column**         (optional) Stream channel width at the start of each flowline</span>
<span class="sd">        **width2_column**         (optional) Stream channel width at the end of each flowline</span>
<span class="sd">        **up_elevation_column**   (optional) Streambed elevation at the start of each flowline</span>
<span class="sd">        **dn_elevation_column**   (optional) Streambed elevation at the end of each flowline</span>
<span class="sd">        **name_column**           (optional) Flowline name</span>
<span class="sd">        **geometry**              shapely :class:`LineString` objects for each feature</span>
<span class="sd">        ========================= =============================================================</span>
<span class="sd">    asum_units : str, optional</span>
<span class="sd">        Length units for values in ``arbolate_sum_column2``; </span>
<span class="sd">        by default &#39;km&#39;.</span>
<span class="sd">    width_units : str, optional</span>
<span class="sd">        Length units for values in ``width1_column`` and ``width2_column``; </span>
<span class="sd">        by default &#39;meters&#39;.</span>
<span class="sd">    elevation_units : str, optional</span>
<span class="sd">        Length units for values in ``up_elevation_column`` and ``dn_elevation_column``; </span>
<span class="sd">        by default &#39;meters&#39;.</span>
<span class="sd">    crs : obj, optional</span>
<span class="sd">        Coordinate reference object for ``df``. This argument is only needed</span>
<span class="sd">        if ``df`` is not a GeoDataFrame with a valid attached coordinate reference.</span>
<span class="sd">        Can be any of:</span>
<span class="sd">        - PROJ string</span>
<span class="sd">        - Dictionary of PROJ parameters</span>
<span class="sd">        - PROJ keyword arguments for parameters</span>
<span class="sd">        - JSON string with PROJ parameters</span>
<span class="sd">        - CRS WKT string</span>
<span class="sd">        - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">        - An EPSG integer code [i.e. 4326]</span>
<span class="sd">        - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">        - An object with a `to_wkt` method.</span>
<span class="sd">        - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">    prjfile: str, optional</span>
<span class="sd">        ESRI-style projection file with coordinate reference information for ``df``. </span>
<span class="sd">        This argument is only needed if ``df`` is not a GeoDataFrame </span>
<span class="sd">        with a valid attached coordinate reference.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Support for deprecated keyword options.</span>

<span class="sd">        .. deprecated:: 0.13</span>
<span class="sd">            The following arguments will be removed in SFRmaker 0.13.</span>

<span class="sd">            - ``attr_length_units`` (str): use ``width_units`` or ``asum_units`` instead.</span>
<span class="sd">            - ``attr_height_units`` (str): use ``elevation_units`` instead.</span>
<span class="sd">            - ``epsg`` (int): use ``crs`` instead.</span>
<span class="sd">            - ``proj_str`` (str): use ``crs`` instead.</span>
<span class="sd">        </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    crs : :class:`sfrmaker.gis.CRS` instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">asum_units</span><span class="o">=</span><span class="s1">&#39;km&#39;</span><span class="p">,</span>
                <span class="n">width_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                <span class="n">elevation_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;attr_length_units&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;attr_length_units argument is deprecated, &quot;</span>
            <span class="s2">&quot;use width_units or asum_units instead&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
            <span class="n">asum_units</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;attr_length_units&#39;</span><span class="p">]</span>
            <span class="n">width_units</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;attr_length_units&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;attr_height_units&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;attr_height_units argument is deprecated, &quot;</span>
            <span class="s2">&quot;use elevation_units instead&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
            <span class="n">elevation_units</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;attr_height_units&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span> <span class="o">=</span> <span class="n">asum_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_units</span> <span class="o">=</span> <span class="n">width_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elevation_units</span> <span class="o">=</span> <span class="n">elevation_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">get_crs</span><span class="p">(</span><span class="n">prjfile</span><span class="o">=</span><span class="n">prjfile</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;crs&#39;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">crs</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Coordinate reference system (CRS) attached to &#39;</span>
                             <span class="s1">&#39;input DataFrame is different than CRS supplied &#39;</span>
                             <span class="s1">&#39;as argument to sfrmaker.Lines!&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_length_units</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dictionary of routing connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_routing_dict_update</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># routing sequence from each segment to outlet</span>

        <span class="c1"># dictionary of elevations at the upstream ends of flowlines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elevup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">elevup</span><span class="p">))</span>
        <span class="c1"># static dictionary of original flowline routing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry_length_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length units of reach LineString geometries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_units</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;feet&#39;</span><span class="p">:</span> <span class="s1">&#39;feet&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;foot&#39;</span><span class="p">:</span> <span class="s1">&#39;feet&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;meters&#39;</span><span class="p">:</span> <span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;metre&#39;</span><span class="p">:</span> <span class="s1">&#39;meters&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Flowline geometries need to be in a &#39;</span>
                             <span class="s1">&#39;projected coordinate system; supply a model grid &#39;</span>
                             <span class="s1">&#39;with a projected CRS to the Lines.to_sfr() method or &#39;</span>
                             <span class="s1">&#39;run Lines.to_crs() to reproject the flowlines.&#39;</span>
                             <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_length_units</span> <span class="o">=</span> <span class="n">valid_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">axis_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_length_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: No length units specified in CRS for input LineStrings &quot;</span>
                  <span class="s2">&quot;or length units not recognized&quot;</span>
                  <span class="s2">&quot;defaulting to meters.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_length_units</span> <span class="o">=</span> <span class="s1">&#39;meters&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_length_units</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of routing connections from ids (keys)</span>
<span class="sd">        to to_ids (values).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Goal is to incorporate any updates in line dataframe</span>
            <span class="c1"># into routing dictionary</span>
            <span class="c1"># if user is trying to update the dataframe from the routing dict</span>
            <span class="c1"># recursion can occur</span>
            <span class="c1"># this checks the last time that self._routing_changed method</span>
            <span class="c1"># recorded different routing information in the dataframe</span>
            <span class="c1"># compared to a cached copy (_current_df_routing)</span>
            <span class="c1"># if the routing dictionary was updated more recently,</span>
            <span class="c1"># we can assume that updates haven&#39;t been made to the routing</span>
            <span class="c1"># in the dataframe</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_routing_dict_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_last_routing_dict_update</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing_time</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing_changed</span><span class="p">():</span>
            <span class="n">toid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">toid</span><span class="o">.</span><span class="n">values</span>
            <span class="c1"># check whether or not routing is</span>
            <span class="c1"># many-to-one or one-to-one (no diversions)</span>
            <span class="c1"># squeeze it down</span>
            <span class="n">to_one</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if below == True, all toids are scalar or length 1 lists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">to_one</span> <span class="o">=</span> <span class="n">is_to_one</span><span class="p">(</span><span class="n">toid</span><span class="p">)</span>
                <span class="c1"># if not, try converting any scalars to lists</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">to_one</span><span class="p">:</span>
                    <span class="n">toid</span> <span class="o">=</span> <span class="p">[[</span><span class="n">l</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">else</span> <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">toid</span><span class="p">]</span>
                    <span class="n">to_one</span> <span class="o">=</span> <span class="n">is_to_one</span><span class="p">(</span><span class="n">toid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">to_one</span><span class="p">:</span>
                    <span class="n">toid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">toid</span><span class="p">))</span>
                <span class="n">routing</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">toid</span><span class="p">,</span>
                                     <span class="n">one_to_many</span><span class="o">=</span><span class="ow">not</span> <span class="n">to_one</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">to_one</span><span class="p">:</span>
                    <span class="n">routing</span> <span class="o">=</span> <span class="n">pick_toids</span><span class="p">(</span><span class="n">routing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevup</span><span class="p">)</span>
                <span class="c1"># set toids not in routing dataset to 0</span>
                <span class="c1"># (outlet condition)</span>
                <span class="n">routing</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">routing</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span> 
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">routing</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">routing</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">0</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span> <span class="o">=</span> <span class="n">routing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_routing_dict_update</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of paths, where each value is a list</span>
<span class="sd">        of downstream lines constituting a flow path to an outlet</span>
<span class="sd">        for a given line (key).</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing_changed</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span>

    <span class="k">def</span> <span class="nf">_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">seg</span><span class="p">:</span> <span class="n">find_path</span><span class="p">(</span><span class="n">routing</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">routing</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">_routing_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check to see if routing in segment data was changed</span>
        <span class="c1"># compare the private routing attribute</span>
        <span class="c1"># to current values in reach data</span>
        <span class="n">df_routing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">toid</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">df_routing</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">df_routing</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing</span> <span class="o">=</span> <span class="n">df_routing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_df_routing_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df_routing</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span>

<div class="viewcode-block" id="Lines.cull">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.cull">[docs]</a>
    <span class="k">def</span> <span class="nf">cull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">feature_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cull linework; retaining only the</span>
<span class="sd">        lines that intersect a polygon feature.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        feature : shapely Polygon, list of Polygons, or shapefile path</span>
<span class="sd">            Polygons must be in same CRS as linework; shapefile</span>
<span class="sd">            features will be reprojected if their crs is different.</span>
<span class="sd">        simplify : bool</span>
<span class="sd">            Option to simplify the polygon, which can speed intersection </span>
<span class="sd">            with the lines.</span>
<span class="sd">        tol: float</span>
<span class="sd">            Simplification tolerance (distance), in the units of the LineStrings</span>
<span class="sd">            (usually meters).</span>
<span class="sd">        feature_crs : obj</span>
<span class="sd">            A Python int, dict, str, or :py:class:`pyproj.crs.CRS` instance</span>
<span class="sd">            passed to the :py:meth:`pyproj.crs.CRS.from_user_input`</span>
<span class="sd">            See http://pyproj4.github.io/pyproj/stable/api/crs/crs.html#pyproj.crs.CRS.from_user_input.</span>
<span class="sd">            Can be any of:</span>

<span class="sd">              - PROJ string</span>
<span class="sd">              - Dictionary of PROJ parameters</span>
<span class="sd">              - PROJ keyword arguments for parameters</span>
<span class="sd">              - JSON string with PROJ parameters</span>
<span class="sd">              - CRS WKT string</span>
<span class="sd">              - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">              - An EPSG integer code [i.e. 4326]</span>
<span class="sd">              - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">              - An object with a `to_wkt` method.</span>
<span class="sd">              - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, the attribute .df is modified;</span>
<span class="sd">            if False, a copy of .df is returned.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : DataFrame</span>
<span class="sd">            Version of the :py:attr:`Lines.df` DataFrame</span>
<span class="sd">            containing only the lines that intersect the ``feature``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Culling hydrography to active area...&#39;</span><span class="p">)</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">feature</span> <span class="o">=</span> <span class="n">read_polygon_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                                       <span class="n">feature_crs</span><span class="o">=</span><span class="n">feature_crs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;simplification tolerance: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol</span><span class="p">))</span>
            <span class="n">feature_s</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_s</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># in case feature is invalid, might fix</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;starting lines: </span><span class="si">{:,d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)))</span>
        <span class="c1"># isn = np.array([g.intersection(feature_s) for g in lines])</span>
        <span class="c1"># df[&#39;geometry&#39;] = isn</span>
        <span class="c1"># drop = np.array([g.is_empty for g in isn])</span>
        <span class="c1"># df = df.loc[~drop]</span>
        <span class="n">intersects</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">feature_s</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">intersects</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No lines in active area. Check CRS for lines, grid and active area polygon.&#39;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">intersects</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>
        <span class="n">drop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">is_empty</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">drop</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;remaining lines: </span><span class="si">{:,d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finished in </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ta</span><span class="p">))</span></div>


<div class="viewcode-block" id="Lines.intersect">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.intersect">[docs]</a>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">size_thresh</span><span class="o">=</span><span class="mf">1e5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect linework with a model grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid : instance of sfrmaker.grid</span>
<span class="sd">            Must have a valid Coordinate Reference System (CRS).</span>
<span class="sd">        size_thresh : int</span>
<span class="sd">            Determines whether spatial indexing will be used. If</span>
<span class="sd">            number of grid cells x number of flowlines &gt; size_thresh,</span>
<span class="sd">            a spatial index (rtree package) will be used to speed</span>
<span class="sd">            up the intersections.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reach_data : DataFrame</span>
<span class="sd">            DataFrame containing intersected reaches with grid cell information</span>
<span class="sd">            and original linework IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.gis</span> <span class="kn">import</span> <span class="n">intersect</span><span class="p">,</span> <span class="n">intersect_rtree</span>

        <span class="c1"># to_crs the flowlines if they aren&#39;t in same CRS as grid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

        <span class="n">grid_polygons</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">stream_linework</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">id_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">ncells</span><span class="p">,</span> <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_polygons</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_linework</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Intersecting </span><span class="si">{:,d}</span><span class="s2"> flowlines with </span><span class="si">{:,d}</span><span class="s2"> grid cells...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nlines</span><span class="p">,</span> <span class="n">ncells</span><span class="p">))</span>
        <span class="c1"># building the spatial index takes a while</span>
        <span class="c1"># only use spatial index if number of tests exceeds size_thresh</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">ncells</span> <span class="o">*</span> <span class="n">nlines</span>
        <span class="c1"># don&#39;t spend time on a spatial index if it isn&#39;t created and problem is small</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">size_thresh</span> <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_intersections</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">grid_polygons</span><span class="p">,</span> <span class="n">stream_linework</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">spatial_index</span>
            <span class="n">grid_intersections</span> <span class="o">=</span> <span class="n">intersect_rtree</span><span class="p">(</span><span class="n">grid_polygons</span><span class="p">,</span> <span class="n">stream_linework</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># create preliminary reaches</span>
        <span class="n">reach_data</span> <span class="o">=</span> <span class="n">setup_reach_data</span><span class="p">(</span><span class="n">stream_linework</span><span class="p">,</span> <span class="n">id_list</span><span class="p">,</span>
                                      <span class="n">grid_intersections</span><span class="p">,</span> <span class="n">grid_polygons</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">.001</span><span class="p">)</span>

        <span class="n">column_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;rno&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;ireach&#39;</span><span class="p">,</span> <span class="s1">&#39;iseg&#39;</span><span class="p">,</span> <span class="s1">&#39;line_id&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>

        <span class="c1"># transfer names</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">reach_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="n">line_id</span><span class="p">]</span> <span class="k">for</span> <span class="n">line_id</span> <span class="ow">in</span> <span class="n">reach_data</span><span class="o">.</span><span class="n">line_id</span><span class="p">]</span>

        <span class="c1"># assign rows and columns from node</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">StructuredGrid</span><span class="p">):</span>
            <span class="n">reach_data</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">reach_data</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">reach_data</span><span class="o">.</span><span class="n">node</span> <span class="o">/</span> <span class="n">grid</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">reach_data</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reach_data</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">values</span> <span class="o">%</span> <span class="n">grid</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">column_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
            <span class="n">column_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reach_data</span><span class="p">[</span><span class="n">column_order</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>



<div class="viewcode-block" id="Lines.make_routing_one_to_one">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.make_routing_one_to_one">[docs]</a>
    <span class="k">def</span> <span class="nf">make_routing_one_to_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># convert routing connections (toid column) from lists (one-to-many)</span>
        <span class="c1"># to ints (one-to-one or many-to-one)</span>
        <span class="n">routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># one to many routing is not supported</span>
        <span class="n">to_one</span> <span class="o">=</span> <span class="n">is_to_one</span><span class="p">(</span><span class="n">routing</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">to_one</span><span class="p">,</span> <span class="s2">&quot;routing is still one-to-many&quot;</span>
        <span class="c1"># if not to_one:</span>
        <span class="c1">#    routing = pick_toids(routing, elevup)</span>
        <span class="n">valid_ids</span> <span class="o">=</span> <span class="n">routing</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># df.toid column is basis for routing attributes</span>
        <span class="c1"># all paths terminating in invalid toids (outside of the model)</span>
        <span class="c1"># will be none; set invalid toids = 0</span>
        <span class="c1"># TODO: write a test for pick_toids if some IDs route to more than one connection</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routing</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span> <span class="s2">&quot;one to many routing not supported&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">toid</span> <span class="o">=</span> <span class="p">[</span><span class="n">routing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">routing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">valid_ids</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span></div>



<div class="viewcode-block" id="Lines.to_crs">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.to_crs">[docs]</a>
    <span class="k">def</span> <span class="nf">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest_crs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reproject the LineStrings in :py:attr:`Lines.df` to</span>
<span class="sd">        a different Coordinate Reference System.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dest_crs : obj</span>
<span class="sd">            A Python int, dict, str, or :py:class:`pyproj.crs.CRS` instance</span>
<span class="sd">            passed to the :py:meth:`pyproj.crs.CRS.from_user_input`</span>
<span class="sd">            See http://pyproj4.github.io/pyproj/stable/api/crs/crs.html#pyproj.crs.CRS.from_user_input.</span>
<span class="sd">            Can be any of:</span>

<span class="sd">              - PROJ string</span>
<span class="sd">              - Dictionary of PROJ parameters</span>
<span class="sd">              - PROJ keyword arguments for parameters</span>
<span class="sd">              - JSON string with PROJ parameters</span>
<span class="sd">              - CRS WKT string</span>
<span class="sd">              - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">              - An EPSG integer code [i.e. 4326]</span>
<span class="sd">              - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">              - An object with a `to_wkt` method.</span>
<span class="sd">              - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No crs for flowlines.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dest_crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No destination CRS to project flowlines to.&quot;</span><span class="p">)</span>

        <span class="n">dest_crs</span> <span class="o">=</span> <span class="n">get_authority_crs</span><span class="p">(</span><span class="n">dest_crs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">reprojecting hydrography from</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">to</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                                                                     <span class="n">dest_crs</span><span class="p">))</span>
        <span class="n">reprojected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">dest_crs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reprojected</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
            <span class="c1"># Try turning off the Proj Network</span>
            <span class="c1"># where PROJ reaches out to the web for projection grids</span>
            <span class="c1"># an invalid reproject can result if there is an SSL issue</span>
            <span class="c1"># https://pyproj4.github.io/pyproj/stable/api/network.html</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Reprojection failed. This could be due to an SSL issue &#39;</span>
                          <span class="s1">&#39;preventing pyproj from accessing the PROJ Network &#39;</span>
                          <span class="s1">&#39;(see https://pyproj4.github.io/pyproj/stable/api/network.html). &#39;</span>
                          <span class="s1">&#39;Trying with pyproj.network.set_network_enabled(False). &#39;</span>
                          <span class="s1">&#39;Are you currently on an internal network or VPN? &#39;</span>
                          <span class="s1">&#39;You might consider re-running this script off of the network.&#39;</span><span class="p">)</span>
            <span class="n">pyproj</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">set_network_enabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">reprojected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">dest_crs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reprojected</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid reprojection; check CRS for lines and grid.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reprojection with with pyproj.network.set_network_enabled(False) &#39;</span>
                      <span class="s1">&#39;succeeded, but please check the results for accuracy.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">reprojected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">dest_crs</span></div>


<div class="viewcode-block" id="Lines.write_shapefile">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.write_shapefile">[docs]</a>
    <span class="k">def</span> <span class="nf">write_shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outshp</span><span class="o">=</span><span class="s1">&#39;flowlines.shp&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a shapefile of :py:attr:`Lines.df`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outshp : str, optional</span>
<span class="sd">            Shapefile name, by default &#39;flowlines.shp&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">df2shp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">outshp</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lines.from_shapefile">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.from_shapefile">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_shapefile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shapefile</span><span class="p">,</span>
                       <span class="n">id_column</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
                       <span class="n">routing_column</span><span class="o">=</span><span class="s1">&#39;toid&#39;</span><span class="p">,</span>
                       <span class="n">arbolate_sum_column2</span><span class="o">=</span><span class="s1">&#39;asum2&#39;</span><span class="p">,</span>
                       <span class="n">asum_units</span><span class="o">=</span><span class="s1">&#39;km&#39;</span><span class="p">,</span>
                       <span class="n">width1_column</span><span class="o">=</span><span class="s1">&#39;width1&#39;</span><span class="p">,</span>
                       <span class="n">width2_column</span><span class="o">=</span><span class="s1">&#39;width2&#39;</span><span class="p">,</span>
                       <span class="n">width_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                       <span class="n">up_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevup&#39;</span><span class="p">,</span>
                       <span class="n">dn_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevdn&#39;</span><span class="p">,</span>
                       <span class="n">elevation_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                       <span class="n">name_column</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>
                       <span class="n">bbox_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Lines instance from a shapefile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapefile : str or pathlike</span>
<span class="sd">            Input shapefile</span>
<span class="sd">        id_column : str, optional</span>
<span class="sd">            Attribute field with line identifiers, </span>
<span class="sd">            by default &#39;id&#39;</span>
<span class="sd">        routing_column : str, optional</span>
<span class="sd">            Attribute field with downstream routing connections,</span>
<span class="sd">            by default &#39;toid&#39;</span>
<span class="sd">        arbolate_sum_column2 : str, optional</span>
<span class="sd">            Attribute field with arbolate sums at downstream ends of lines, </span>
<span class="sd">            by default &#39;asum2&#39;</span>
<span class="sd">        asum_units : str, optional</span>
<span class="sd">            Length units for values in ``arbolate_sum_column2``; </span>
<span class="sd">            by default &#39;km&#39;.</span>
<span class="sd">        width1_column : str, optional</span>
<span class="sd">            Attribute field with channel widths at upstream ends of lines,</span>
<span class="sd">            by default &#39;width1&#39;</span>
<span class="sd">        width2_column : str, optional</span>
<span class="sd">            Attribute field with channel widths at downstream ends of lines, </span>
<span class="sd">            by default &#39;width2&#39;</span>
<span class="sd">        width_units : str, optional</span>
<span class="sd">            Length units for values in ``width1_column`` and ``width2_column``; </span>
<span class="sd">            by default &#39;meters&#39;.</span>
<span class="sd">        up_elevation_column : str, optional</span>
<span class="sd">            Attribute field with elevations at upstream ends of lines, </span>
<span class="sd">            by default &#39;elevup&#39;</span>
<span class="sd">        dn_elevation_column : str, optional</span>
<span class="sd">            Attribute field with elevations at downstream ends of lines,</span>
<span class="sd">            by default &#39;elevdn&#39;</span>
<span class="sd">        elevation_units : str, optional</span>
<span class="sd">            Length units for values in ``up_elevation_column`` and ``dn_elevation_column``; </span>
<span class="sd">            by default &#39;meters&#39;.</span>
<span class="sd">        name_column : str, optional</span>
<span class="sd">            Attribute field with feature names, </span>
<span class="sd">            by default &#39;name&#39;</span>
<span class="sd">        bbox_filter : tuple, optional</span>
<span class="sd">            (xmin, ymin, xmax, ymax) bounding box to filter which records </span>
<span class="sd">            are read from the shapefile. By default None.</span>
<span class="sd">        crs : obj, optional</span>
<span class="sd">            Coordinate reference object for ``shapefile``. This argument is only needed</span>
<span class="sd">            if ``shapefile`` does not include a valid projection file.</span>
<span class="sd">            Can be any of:</span>
<span class="sd">            - PROJ string</span>
<span class="sd">            - Dictionary of PROJ parameters</span>
<span class="sd">            - PROJ keyword arguments for parameters</span>
<span class="sd">            - JSON string with PROJ parameters</span>
<span class="sd">            - CRS WKT string</span>
<span class="sd">            - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">            - An EPSG integer code [i.e. 4326]</span>
<span class="sd">            - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">            - An object with a `to_wkt` method.</span>
<span class="sd">            - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">        prjfile: str, optional</span>
<span class="sd">            ESRI-style projection file with coordinate reference information for ``df``. </span>
<span class="sd">            This argument is only needed</span>
<span class="sd">            if ``shapefile`` does not include a valid projection file.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Support for deprecated keyword options.</span>

<span class="sd">            .. deprecated:: 0.13</span>
<span class="sd">                The following arguments will be removed in SFRmaker 0.13.</span>

<span class="sd">                - ``attr_length_units`` (str): use ``width_units`` or ``asum_units`` instead.</span>
<span class="sd">                - ``attr_height_units`` (str): use ``elevation_units`` instead.</span>
<span class="sd">                - ``epsg`` (int): use ``crs`` instead.</span>
<span class="sd">                - ``proj_str`` (str): use ``crs`` instead.</span>
<span class="sd">                - ``filter`` (tuple): use ``bbox_filter`` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : :class:`Lines` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="s1">&#39;filter&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;filter argument is deprecated, &quot;</span>
            <span class="s2">&quot;use bbox_filter instead&quot;</span><span class="p">,</span>
            <span class="ne">PendingDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
            <span class="n">bbox_filter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">prjfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prjfile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.shp&#39;</span><span class="p">,</span> <span class="s1">&#39;.prj&#39;</span><span class="p">)</span>
            <span class="n">prjfile</span> <span class="o">=</span> <span class="n">prjfile</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">prjfile</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prjfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shpfile_crs</span> <span class="o">=</span> <span class="n">get_shapefile_crs</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">prjfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shpfile_crs</span> <span class="o">=</span> <span class="n">get_shapefile_crs</span><span class="p">(</span><span class="n">prjfile</span><span class="p">)</span>
        <span class="c1"># ensure that bbox_filter bbox is in same crs as flowlines</span>
        <span class="k">if</span> <span class="n">bbox_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox_filter</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">bbox_filter</span> <span class="o">=</span> <span class="n">get_bbox</span><span class="p">(</span><span class="n">bbox_filter</span><span class="p">,</span> <span class="n">shpfile_crs</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox_filter</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;No feature geometries found in </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                                  <span class="n">id_column</span><span class="o">=</span><span class="n">id_column</span><span class="p">,</span>
                                  <span class="n">routing_column</span><span class="o">=</span><span class="n">routing_column</span><span class="p">,</span>
                                  <span class="n">arbolate_sum_column2</span><span class="o">=</span><span class="n">arbolate_sum_column2</span><span class="p">,</span>
                                  <span class="n">asum_units</span><span class="o">=</span><span class="n">asum_units</span><span class="p">,</span>
                                  <span class="n">width1_column</span><span class="o">=</span><span class="n">width1_column</span><span class="p">,</span>
                                  <span class="n">width2_column</span><span class="o">=</span><span class="n">width2_column</span><span class="p">,</span>
                                  <span class="n">width_units</span><span class="o">=</span><span class="n">width_units</span><span class="p">,</span>
                                  <span class="n">up_elevation_column</span><span class="o">=</span><span class="n">up_elevation_column</span><span class="p">,</span>
                                  <span class="n">dn_elevation_column</span><span class="o">=</span><span class="n">dn_elevation_column</span><span class="p">,</span>
                                  <span class="n">elevation_units</span><span class="o">=</span><span class="n">elevation_units</span><span class="p">,</span>
                                  <span class="n">name_column</span><span class="o">=</span><span class="n">name_column</span><span class="p">,</span>
                                  <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="n">prjfile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lines.from_dataframe">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.from_dataframe">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
                       <span class="n">id_column</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
                       <span class="n">routing_column</span><span class="o">=</span><span class="s1">&#39;toid&#39;</span><span class="p">,</span>
                       <span class="n">arbolate_sum_column2</span><span class="o">=</span><span class="s1">&#39;asum2&#39;</span><span class="p">,</span>
                       <span class="n">asum_units</span><span class="o">=</span><span class="s1">&#39;km&#39;</span><span class="p">,</span>
                       <span class="n">width1_column</span><span class="o">=</span><span class="s1">&#39;width1&#39;</span><span class="p">,</span>
                       <span class="n">width2_column</span><span class="o">=</span><span class="s1">&#39;width2&#39;</span><span class="p">,</span>
                       <span class="n">width_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                       <span class="n">up_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevup&#39;</span><span class="p">,</span>
                       <span class="n">dn_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevdn&#39;</span><span class="p">,</span>
                       <span class="n">elevation_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                       <span class="n">geometry_column</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                       <span class="n">name_column</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>
                       <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;[summary]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : DataFrame</span>
<span class="sd">            Pandas DataFrame or Geopandas GeoDataFrame</span>
<span class="sd">            with flowline information, including</span>
<span class="sd">            shapely :class:`LineStrings &lt;LineString&gt;` in a `&#39;geometry&#39;` column.</span>
<span class="sd">        id_column : str, optional</span>
<span class="sd">            Attribute field with line identifiers, </span>
<span class="sd">            by default &#39;id&#39;</span>
<span class="sd">        routing_column : str, optional</span>
<span class="sd">            Attribute field with downstream routing connections,</span>
<span class="sd">            by default &#39;toid&#39;</span>
<span class="sd">        arbolate_sum_column2 : str, optional</span>
<span class="sd">            Attribute field with arbolate sums at downstream ends of lines, </span>
<span class="sd">            by default &#39;asum2&#39;</span>
<span class="sd">        asum_units : str, optional</span>
<span class="sd">            Length units for values in ``arbolate_sum_column2``; </span>
<span class="sd">            by default &#39;km&#39;.</span>
<span class="sd">        width1_column : str, optional</span>
<span class="sd">            Attribute field with channel widths at upstream ends of lines,</span>
<span class="sd">            by default &#39;width1&#39;</span>
<span class="sd">        width2_column : str, optional</span>
<span class="sd">            Attribute field with channel widths at downstream ends of lines, </span>
<span class="sd">            by default &#39;width2&#39;</span>
<span class="sd">        width_units : str, optional</span>
<span class="sd">            Length units for values in ``width1_column`` and ``width2_column``; </span>
<span class="sd">            by default &#39;meters&#39;.</span>
<span class="sd">        up_elevation_column : str, optional</span>
<span class="sd">            Attribute field with elevations at upstream ends of lines, </span>
<span class="sd">            by default &#39;elevup&#39;</span>
<span class="sd">        dn_elevation_column : str, optional</span>
<span class="sd">            Attribute field with elevations at downstream ends of lines,</span>
<span class="sd">            by default &#39;elevdn&#39;</span>
<span class="sd">        elevation_units : str, optional</span>
<span class="sd">            Length units for values in ``up_elevation_column`` and ``dn_elevation_column``; </span>
<span class="sd">            by default &#39;meters&#39;.</span>
<span class="sd">        name_column : str, optional</span>
<span class="sd">            Attribute field with feature names, </span>
<span class="sd">            by default &#39;name&#39;</span>
<span class="sd">        crs : obj, optional</span>
<span class="sd">            Coordinate reference object for ``df``. This argument is only needed</span>
<span class="sd">            if ``df`` is not a GeoDataFrame with a valid attached coordinate reference.</span>
<span class="sd">            Can be any of:</span>
<span class="sd">            - PROJ string</span>
<span class="sd">            - Dictionary of PROJ parameters</span>
<span class="sd">            - PROJ keyword arguments for parameters</span>
<span class="sd">            - JSON string with PROJ parameters</span>
<span class="sd">            - CRS WKT string</span>
<span class="sd">            - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">            - An EPSG integer code [i.e. 4326]</span>
<span class="sd">            - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">            - An object with a `to_wkt` method.</span>
<span class="sd">            - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">        prjfile: str, optional</span>
<span class="sd">            ESRI-style projection file with coordinate reference information for ``df``. </span>
<span class="sd">            This argument is only needed if ``df`` is not a GeoDataFrame </span>
<span class="sd">            with a valid attached coordinate reference.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Support for deprecated keyword options.</span>

<span class="sd">            .. deprecated:: 0.13</span>
<span class="sd">                The following arguments will be removed in SFRmaker 0.13.</span>

<span class="sd">                - ``attr_length_units`` (str): use ``width_units`` or ``asum_units`` instead.</span>
<span class="sd">                - ``attr_height_units`` (str): use ``elevation_units`` instead.</span>
<span class="sd">                - ``epsg`` (int): use ``crs`` instead.</span>
<span class="sd">                - ``proj_str`` (str): use ``crs`` instead.</span>
<span class="sd">             </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : :class:`Lines` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">geometry_column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> \
            <span class="s2">&quot;No feature geometries found: dataframe column &#39;</span><span class="si">{}</span><span class="s2">&#39; doesn&#39;t exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">geometry_column</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">routing_column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> \
            <span class="s2">&quot;No routing information found; dataframe column &#39;</span><span class="si">{}</span><span class="s2">&#39; doesn&#39;t exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">routing_column</span><span class="p">)</span>

        <span class="c1"># rename the columns for consistency</span>
        <span class="n">rename_cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">id_column</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                       <span class="n">routing_column</span><span class="p">:</span> <span class="s1">&#39;toid&#39;</span><span class="p">,</span>
                       <span class="n">arbolate_sum_column2</span><span class="p">:</span> <span class="s1">&#39;asum2&#39;</span><span class="p">,</span>
                       <span class="n">width1_column</span><span class="p">:</span> <span class="s1">&#39;width1&#39;</span><span class="p">,</span>
                       <span class="n">width2_column</span><span class="p">:</span> <span class="s1">&#39;width2&#39;</span><span class="p">,</span>
                       <span class="n">up_elevation_column</span><span class="p">:</span> <span class="s1">&#39;elevup&#39;</span><span class="p">,</span>
                       <span class="n">dn_elevation_column</span><span class="p">:</span> <span class="s1">&#39;elevdn&#39;</span><span class="p">,</span>
                       <span class="n">name_column</span><span class="p">:</span> <span class="s1">&#39;name&#39;</span><span class="p">}</span>

        <span class="c1"># dictionary for assigning new column names</span>
        <span class="n">rename_cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rename_cols</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">k</span><span class="p">}</span>
        <span class="c1"># drop any existing columns that have one of the new names</span>
        <span class="c1"># (otherwise pandas will create a DataFrame</span>
        <span class="c1"># instead of a Series under that column name)</span>
        <span class="n">to_drop</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rename_cols</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">rename_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">column_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;toid&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;asum1&#39;</span><span class="p">,</span> <span class="s1">&#39;asum2&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;width1&#39;</span><span class="p">,</span> <span class="s1">&#39;width2&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;elevup&#39;</span><span class="p">,</span> <span class="s1">&#39;elevdn&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_order</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> 
                   <span class="n">asum_units</span><span class="o">=</span><span class="n">asum_units</span><span class="p">,</span>
                   <span class="n">width_units</span><span class="o">=</span><span class="n">width_units</span><span class="p">,</span> 
                   <span class="n">elevation_units</span><span class="o">=</span><span class="n">elevation_units</span><span class="p">,</span>
                   <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="n">prjfile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lines.from_nhdplus_v2">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.from_nhdplus_v2">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_nhdplus_v2</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">NHDPlus_paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">NHDFlowlines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PlusFlowlineVAA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PlusFlow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elevslope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">bbox_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        NHDPlus_paths : str or list of strings</span>
<span class="sd">            List of paths to the root folders of NHDPlus drainage basins</span>
<span class="sd">            to include, assuming the file structure is the same as</span>
<span class="sd">            downloaded from the NHDPlus version 2 website. For example::</span>
<span class="sd">            </span>
<span class="sd">                NHDPlus_paths=[&#39;/NHDPlusGL/NHDPlus04/&#39;,</span>
<span class="sd">                               &#39;/NHDPlusMS/NHDPlus07/&#39;]    </span>
<span class="sd">                                     </span>
<span class="sd">            for the Great Lakes (04) and Upper Mississippi (07) basins.      </span>
<span class="sd">        NHDFlowlines : str or list of strings.</span>
<span class="sd">            Shapefile or list of NHDFlowline shapefiles containing</span>
<span class="sd">            feature geometries (line arcs) for stream network. Must contain</span>
<span class="sd">            the following attribute fields:</span>
<span class="sd">            COMID : common identifier number</span>
<span class="sd">        PlusFlowlineVAA : str or list of strings.</span>
<span class="sd">            DBF file or list of DBF files with NHDPlus attribute information.</span>
<span class="sd">            Must contain the following attribute fields:</span>
<span class="sd">            COMID : common identifier number</span>
<span class="sd">        PlusFlow : str or list of strings.</span>
<span class="sd">            DBF file or list of DBF files with NHDPlus routing information.</span>
<span class="sd">            Must contain the following attribute fields:</span>
<span class="sd">            COMID : common identifier number</span>
<span class="sd">        elevslope : str or list of strings.</span>
<span class="sd">            DBF file or list of DBF files with end elevations for each</span>
<span class="sd">            line arc in NHDFlowlines. Must contain the following attribute fields:</span>
<span class="sd">            COMID : common identifier number</span>
<span class="sd">        bbox_filter : tuple or str</span>
<span class="sd">            Bounding box (tuple) or shapefile of model stream network area.</span>
<span class="sd">        crs : obj, optional</span>
<span class="sd">            Coordinate reference object for ``df``. This argument is only needed</span>
<span class="sd">            if the input flowlines don&#39;t have a valid projection file.</span>
<span class="sd">            Can be any of:</span>
<span class="sd">            - PROJ string</span>
<span class="sd">            - Dictionary of PROJ parameters</span>
<span class="sd">            - PROJ keyword arguments for parameters</span>
<span class="sd">            - JSON string with PROJ parameters</span>
<span class="sd">            - CRS WKT string</span>
<span class="sd">            - An authority string [i.e. &#39;epsg:4326&#39;]</span>
<span class="sd">            - An EPSG integer code [i.e. 4326]</span>
<span class="sd">            - A tuple of (&quot;auth_name&quot;: &quot;auth_code&quot;) [i.e (&#39;epsg&#39;, &#39;4326&#39;)]</span>
<span class="sd">            - An object with a `to_wkt` method.</span>
<span class="sd">            - A :class:`pyproj.crs.CRS` class</span>
<span class="sd">        prjfile: str, optional</span>
<span class="sd">            ESRI-style projection file with coordinate reference information for ``df``. </span>
<span class="sd">            This argument is only needed</span>
<span class="sd">            if the input flowlines don&#39;t have a valid projection file.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Support for deprecated keyword options.</span>

<span class="sd">            .. deprecated:: 0.13</span>
<span class="sd">                The following arguments will be removed in SFRmaker 0.13.</span>
<span class="sd">                </span>
<span class="sd">                - ``epsg`` (int): use ``crs`` instead.</span>
<span class="sd">                - ``proj_str`` (str): use ``crs`` instead.</span>
<span class="sd">                - ``filter`` (tuble): use ``bbox_filter`` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : :class:`Lines` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">load_nhdplus_v2</span><span class="p">(</span><span class="n">NHDPlus_paths</span><span class="o">=</span><span class="n">NHDPlus_paths</span><span class="p">,</span>
                             <span class="n">NHDFlowlines</span><span class="o">=</span><span class="n">NHDFlowlines</span><span class="p">,</span> <span class="n">PlusFlowlineVAA</span><span class="o">=</span><span class="n">PlusFlowlineVAA</span><span class="p">,</span>
                             <span class="n">PlusFlow</span><span class="o">=</span><span class="n">PlusFlow</span><span class="p">,</span> <span class="n">elevslope</span><span class="o">=</span><span class="n">elevslope</span><span class="p">,</span>
                             <span class="n">bbox_filter</span><span class="o">=</span><span class="n">bbox_filter</span><span class="p">,</span>
                             <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="n">prjfile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prjfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prjfile</span> <span class="o">=</span> <span class="n">get_prj_file</span><span class="p">(</span><span class="n">NHDPlus_paths</span><span class="p">,</span> <span class="n">NHDFlowlines</span><span class="p">)</span>

        <span class="c1"># convert arbolate sums from km to m</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">ArbolateSu</span> <span class="o">-</span> <span class="n">df</span><span class="o">.</span><span class="n">LENGTHKM</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ArbolateSu</span> <span class="o">*</span> <span class="mi">1000</span>

        <span class="c1"># convert comid end elevations from cm to m</span>
        <span class="k">if</span> <span class="s1">&#39;MAXELEVSMO&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;elevup&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MAXELEVSMO</span> <span class="o">/</span> <span class="mf">100.</span>
        <span class="k">if</span> <span class="s1">&#39;MINELEVSMO&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;elevdn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MINELEVSMO</span> <span class="o">/</span> <span class="mf">100.</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_column</span><span class="o">=</span><span class="s1">&#39;COMID&#39;</span><span class="p">,</span>
                                  <span class="n">routing_column</span><span class="o">=</span><span class="s1">&#39;tocomid&#39;</span><span class="p">,</span>
                                  <span class="n">name_column</span><span class="o">=</span><span class="s1">&#39;GNIS_NAME&#39;</span><span class="p">,</span>
                                  <span class="n">asum_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                                  <span class="n">elevation_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                                  <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">prjfile</span><span class="o">=</span><span class="n">prjfile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lines.from_nhdplus_hr">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.from_nhdplus_hr">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_nhdplus_hr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">NHDPlusHR_paths</span><span class="p">,</span> <span class="n">bbox_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">drop_fcodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_ftypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_NHDPlusIDs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        NHDPlusHR_paths : str or list of strings</span>
<span class="sd">            path (or list of paths) to the NHDPlus High Resolution HU-4 Subregion </span>
<span class="sd">            file geodatabase (.gdb) to include, assuming the file structure is </span>
<span class="sd">            the same as when downloaded from the USGS National Map Downloader tool </span>
<span class="sd">            (v2.0) website (https://apps.nationalmap.gov/downloader/#/). For example::</span>
<span class="sd">            </span>
<span class="sd">                NHDPlusHR_paths=[&#39;/NHDPLUS_HR_1/NHDPLUS_H_0202_HU4_GDB.gdb&#39;,</span>
<span class="sd">                                    &#39;/NHDPLUS_HR_2/NHDPLUS_H_0204_HU4_GDB.gdb&#39;] </span>
<span class="sd">                                                </span>
<span class="sd">            for the 4-digit Hydrologic Units 0202 and 0204.      </span>
<span class="sd">        bbox_filter : tuple or str, optional</span>
<span class="sd">            Bounding box (tuple) or shapefile of model stream network area.</span>
<span class="sd">        drop_fcodes : int or list of ints, optional</span>
<span class="sd">            fcode or list of NHDFlowline FCodes to drop from network. </span>
<span class="sd">            For example, to remove underground aqueducts and general case</span>
<span class="sd">            water pipelines from line network::</span>
<span class="sd">                </span>
<span class="sd">                drop_fcodes = [42803, 42814]</span>
<span class="sd">        drop_ftypes : int or list of ints, optional</span>
<span class="sd">            List of NHDFlowline FTypes to drop from network.</span>
<span class="sd">            For example, to remove all pipelines from line network::</span>

<span class="sd">                drop_fcodes = [428]</span>
<span class="sd">        drop_NHDPlusIDs : int or list of ints, optional</span>
<span class="sd">            List of NHDFlowlines (as NHDPlusIDs) to drop from network.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Support for deprecated keyword options.</span>

<span class="sd">            .. deprecated:: 0.13</span>
<span class="sd">                The following arguments will be removed in SFRmaker 0.13.</span>
<span class="sd">            </span>
<span class="sd">                - ``crs``: NHDPlus HR data are assumed to include valid projection information.</span>
<span class="sd">                - ``epsg`` (int): NHDPlus HR data are assumed to include valid projection information.</span>
<span class="sd">                - ``proj_str`` (str): NHDPlus HR data are assumed to include valid projection information.</span>
<span class="sd">                - ``filter`` (tuble): use ``bbox_filter`` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        ==========</span>
<span class="sd">        lines : :class:`Lines` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">load_nhdplus_hr</span><span class="p">(</span><span class="n">NHDPlusHR_paths</span><span class="p">,</span> <span class="n">bbox_filter</span><span class="o">=</span><span class="n">bbox_filter</span><span class="p">,</span> <span class="n">drop_fcodes</span><span class="o">=</span><span class="n">drop_fcodes</span><span class="p">,</span> 
                             <span class="n">drop_ftypes</span><span class="o">=</span><span class="n">drop_ftypes</span><span class="p">,</span> <span class="n">drop_NHDPlusIDs</span><span class="o">=</span><span class="n">drop_NHDPlusIDs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1">#  check to see if flowline geodataframe needs to be reprojected, and get new CRS</span>
        <span class="c1">#if crs is not None or epsg is not None or proj_str is not None:</span>
        <span class="c1">#    if crs is not None:</span>
        <span class="c1">#        crs = get_authority_crs(crs)</span>
        <span class="c1">#    if epsg is not None:</span>
        <span class="c1">#        if crs is None:</span>
        <span class="c1">#            crs = get_authority_crs(epsg)</span>
        <span class="c1">#    elif proj_str is not None:</span>
        <span class="c1">#        if crs is None:</span>
        <span class="c1">#            crs = get_authority_crs(proj_str)</span>
        <span class="c1">#    epsg = crs.to_epsg()</span>
        <span class="c1">#    proj_str = crs.to_proj4()</span>
        <span class="c1">#    </span>
        <span class="c1">#    #  reproject</span>
        <span class="c1">#    df = df.to_crs(crs)</span>
<span class="c1">#</span>
        <span class="c1">##  if not, use NHDPlus HR CRS</span>
        <span class="c1">#else:</span>
        <span class="c1">#    crs = get_authority_crs(gdb_crs)</span>
        <span class="c1">#    epsg = crs.to_epsg()</span>
        <span class="c1">#    proj_str = crs.to_proj4()</span>

        <span class="c1"># convert arbolate sums from km to m</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ArbolateSu</span> <span class="o">*</span> <span class="mi">1000</span>

        <span class="c1"># convert NHDPlusID end elevations from cm to m</span>
        <span class="k">if</span> <span class="s1">&#39;MaxElevSmo&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;elevup&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MaxElevSmo</span> <span class="o">/</span> <span class="mf">100.</span>
        <span class="k">if</span> <span class="s1">&#39;MinElevSmo&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;elevdn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MinElevSmo</span> <span class="o">/</span> <span class="mf">100.</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_column</span><span class="o">=</span><span class="s1">&#39;NHDPlusID&#39;</span><span class="p">,</span>
                                  <span class="n">routing_column</span><span class="o">=</span><span class="s1">&#39;ToNHDPID&#39;</span><span class="p">,</span>
                                  <span class="n">name_column</span><span class="o">=</span><span class="s1">&#39;GNIS_Name&#39;</span><span class="p">,</span>
                                  <span class="n">arbolate_sum_column2</span><span class="o">=</span><span class="s1">&#39;asum2&#39;</span><span class="p">,</span>
                                  <span class="n">asum_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                                  <span class="n">up_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevup&#39;</span><span class="p">,</span>
                                  <span class="n">dn_elevation_column</span><span class="o">=</span><span class="s1">&#39;elevdn&#39;</span><span class="p">,</span>
                                  <span class="n">elevation_units</span><span class="o">=</span><span class="s1">&#39;meters&#39;</span><span class="p">,</span>
                                  <span class="n">geometry_column</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Lines.to_sfr">
<a class="viewcode-back" href="../../api/sfrmaker.lines.html#sfrmaker.lines.Lines.to_sfr">[docs]</a>
    <span class="k">def</span> <span class="nf">to_sfr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">active_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isfr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">model_length_units</span><span class="o">=</span><span class="s1">&#39;undefined&#39;</span><span class="p">,</span>
               <span class="n">model_time_units</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span>
               <span class="n">minimum_reach_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">width_from_asum_a_param</span><span class="o">=</span><span class="mf">0.1193</span><span class="p">,</span>
               <span class="n">width_from_asum_b_param</span><span class="o">=</span><span class="mf">0.5032</span><span class="p">,</span>
               <span class="n">minimum_reach_width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
               <span class="n">consolidate_conductance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">one_reach_per_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">add_outlets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">package_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a streamflow routing dataset from the information</span>
<span class="sd">        in sfrmaker.lines class instance and a supplied sfrmaker.grid class instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid : sfrmaker.grid or flopy.discretization.StructuredGrid</span>
<span class="sd">            Numerical model grid instance. Required unless an attached model</span>
<span class="sd">            has a valid modelgrid attribute.</span>
<span class="sd">        active_area : shapely Polygon, list of shapely Polygons, or shapefile path; optional</span>
<span class="sd">            Shapely Polygons must be in same CRS as input flowlines; shapefile</span>
<span class="sd">            features will be reprojected if their crs is different.</span>
<span class="sd">        isfr : ndarray, optional</span>
<span class="sd">            Numpy integer array of the same size as the model grid, designating area that will</span>
<span class="sd">            be populated with SFR reaches (0=no SFR; 1=SFR). An isfr array of shape</span>
<span class="sd">            nrow x ncol will be broadcast to all layers. Only required if a model is not</span>
<span class="sd">            supplied, or if SFR is only desired in a subset of active model cells.</span>
<span class="sd">            By default, None, in which case the model ibound or idomain array will be used.</span>
<span class="sd">        model : flopy.modflow.Modflow or flopy.mf6.ModflowGwf, optional</span>
<span class="sd">            Flopy model instance</span>
<span class="sd">        model_length_units : str; e.g. {&#39;ft&#39;, &#39;feet&#39;, &#39;meters&#39;, etc.}, optional</span>
<span class="sd">            Length units of the model. While SFRmaker will try to read these</span>
<span class="sd">            from a supplied grid (first) and then a supplied model (second),</span>
<span class="sd">            it is good practice to specify them explicitly here.</span>
<span class="sd">        model_time_units : str; e.g. {&#39;d&#39;, &#39;days&#39;}, optional</span>
<span class="sd">            Time units for model. By default, days.</span>
<span class="sd">        minimum_reach_length : float, optional</span>
<span class="sd">            Minimum reach length to retain. Default is to compute</span>
<span class="sd">            an effective mean model cell length by taking the square root</span>
<span class="sd">            of the average cell area, and then set minimum_reach_length</span>
<span class="sd">            to 5% of effective mean cell length.</span>
<span class="sd">        width_from_asum_a_param : float, optional</span>
<span class="sd">            :math:`a` parameter used for estimating channel width from arbolate sum.</span>
<span class="sd">            Only needed if input flowlines are lacking width information.</span>
<span class="sd">            See :func:`~sfrmaker.utils.width_from_arbolate`. By default, 0.1193.</span>
<span class="sd">        width_from_asum_b_param : float, optional</span>
<span class="sd">            :math:`b` parameter used for estimating channel width from arbolate sum.</span>
<span class="sd">            Only needed if input flowlines are lacking width information.</span>
<span class="sd">            See :func:`~sfrmaker.utils.width_from_arbolate`. By default, 0.5032.</span>
<span class="sd">        minimum_reach_width : float, optional</span>
<span class="sd">            Minimum reach width to specify (in model units), if computing widths from</span>
<span class="sd">            arbolate sum values. (default = 1)</span>
<span class="sd">        consolidate_conductance : bool</span>
<span class="sd">            If True, total reach conductance each cell is computed, and</span>
<span class="sd">            assigned to the most downstream reach via the hydraulic conductivity</span>
<span class="sd">            parameter.</span>
<span class="sd">        one_reach_per_cell : bool</span>
<span class="sd">            If True, streambed conductance in each reach is consolidated</span>
<span class="sd">            (consolidate_conductance = True), and additional reaches besides</span>
<span class="sd">            the most downstream reach are dropped.</span>
<span class="sd">        add_outlets : sequence of ints</span>
<span class="sd">            Option to add breaks in routing at specified line ids. For example</span>
<span class="sd">            if controlled flows out of a reservoir are specified as inflows</span>
<span class="sd">            to the SFR network, an outlet can be added above to the dam to</span>
<span class="sd">            prevent double-counting of flow. By default, None</span>
<span class="sd">        package_name : str</span>
<span class="sd">            Base name for writing sfr output.</span>
<span class="sd">        kwargs : keyword arguments to :class:`SFRData`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sfrdata : sfrmaker.SFRData instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">SFRmaker version </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sfrmaker</span><span class="o">.</span><span class="n">__version__</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Creating sfr dataset...&quot;</span><span class="p">)</span>
        <span class="n">totim</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">flopy</span> <span class="ow">and</span> <span class="n">active_area</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;mf6&#39;</span><span class="p">:</span>
                <span class="n">isfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">dis</span><span class="o">.</span><span class="n">idomain</span><span class="o">.</span><span class="n">array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">bas6</span><span class="o">.</span><span class="n">ibound</span><span class="o">.</span><span class="n">array</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># get an SFRmaker StructuredGrid instance of the model grid</span>
        <span class="k">if</span> <span class="n">flopy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">flopy</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">StructuredGrid</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Creating grid class instance from flopy Grid instance...&#39;</span><span class="p">)</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">StructuredGrid</span><span class="o">.</span><span class="n">from_modelgrid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">active_area</span><span class="o">=</span><span class="n">active_area</span><span class="p">,</span> <span class="n">isfr</span><span class="o">=</span><span class="n">isfr</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;grid class created in </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ta</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">sfrmaker</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">flopy</span> <span class="ow">and</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">StructuredGrid</span><span class="o">.</span><span class="n">from_modelgrid</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">modelgrid</span><span class="p">,</span> <span class="n">active_area</span><span class="o">=</span><span class="n">active_area</span><span class="p">,</span> <span class="n">isfr</span><span class="o">=</span><span class="n">isfr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized input for grid: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>

        <span class="c1"># print grid information to screen</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># print model information to screen</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># reproject the flowlines if they aren&#39;t in same CRS as grid</span>
        <span class="c1"># this also needs to be done before </span>
        <span class="c1"># the geometry_length_units property is computed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            
        <span class="n">model_length_units</span> <span class="o">=</span> <span class="n">get_length_units</span><span class="p">(</span><span class="n">model_length_units</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
        <span class="n">width_units_conversion</span> <span class="o">=</span> <span class="n">convert_length_units</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width_units</span><span class="p">,</span> <span class="n">model_length_units</span><span class="p">)</span>
        <span class="n">elevation_units_conversion</span> <span class="o">=</span> <span class="n">convert_length_units</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elevation_units</span><span class="p">,</span> <span class="n">model_length_units</span><span class="p">)</span>
        <span class="n">crs_units_conversion</span> <span class="o">=</span> <span class="n">convert_length_units</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry_length_units</span><span class="p">,</span> <span class="n">model_length_units</span><span class="p">)</span>

        <span class="c1"># cull the flowlines to the active part of the model grid</span>
        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">active_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cull</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">active_area</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">grid</span><span class="o">.</span><span class="n">_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># cull to grid bounding box if already computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cull</span><span class="p">(</span><span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">package_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">package_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">package_name</span> <span class="o">=</span> <span class="s1">&#39;model&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">make_routing_one_to_one</span><span class="p">()</span>

        <span class="c1"># intersect lines with model grid to get preliminary reaches</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># cull the dataframe of lines to only those with reaches</span>
        <span class="c1"># (if grid is rotated, the bounding box of lines will include lines</span>
        <span class="c1">#  that are not in the rotated area of reaches; need lines data</span>
        <span class="c1">#  to be consistent with reach data because it becomes the basis for </span>
        <span class="c1">#  segment data)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">rd</span><span class="p">[</span><span class="s1">&#39;line_id&#39;</span><span class="p">])]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_outlets</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;toid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">new_outlets</span><span class="p">,</span> <span class="s1">&#39;toid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># update the routing again</span>
        <span class="n">routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># length of intersected line fragments (in model units)</span>
        <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;rchlen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">rd</span><span class="o">.</span><span class="n">geometry</span><span class="p">])</span> <span class="o">*</span> <span class="n">crs_units_conversion</span>

        <span class="c1"># compute arbolate sums for original LineStrings if they weren&#39;t provided</span>
        <span class="c1"># output all asums in meters</span>
        <span class="k">if</span> <span class="s1">&#39;asum2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">line_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">])</span> <span class="o">*</span> \
                <span class="n">convert_length_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry_length_units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">)</span>
            <span class="n">line_lengths_lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">line_lengths</span><span class="p">)),</span>
            <span class="n">asums</span> <span class="o">=</span> <span class="n">arbolate_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                 <span class="n">lengths</span><span class="o">=</span><span class="n">line_lengths_lookup</span><span class="p">,</span>
                                 <span class="n">routing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asums</span>

        <span class="c1"># populate starting asums (asum1)</span>
        <span class="k">if</span> <span class="s1">&#39;asum1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length_conversion</span> <span class="o">=</span> <span class="n">convert_length_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry_length_units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">)</span>
            <span class="n">line_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="n">length_conversion</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;asum2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">line_lengths</span>
            
        <span class="n">asum1s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">asum1</span><span class="p">))</span>

        <span class="c1"># compute arbolate sum at reach midpoints</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">rd</span><span class="p">[[</span><span class="s1">&#39;line_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ireach&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lengths</span><span class="p">[</span><span class="s1">&#39;rchlen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">lengths</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;line_id&#39;</span><span class="p">)</span>  <span class="c1"># fragments grouped by parent line</span>

        <span class="n">reach_cumsums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ordered_ids</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ordered_ids</span><span class="p">:</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;ireach&#39;</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">rchlen</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">grp</span><span class="o">.</span><span class="n">rchlen</span><span class="o">.</span><span class="n">values</span>
            <span class="n">reach_cumsums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">reach_cumsums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">reach_cumsums</span><span class="p">)</span>
        <span class="n">segment_asums</span> <span class="o">=</span> <span class="p">[</span><span class="n">asum1s</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">lengths</span><span class="o">.</span><span class="n">line_id</span><span class="p">]</span>
        <span class="n">reach_asums</span> <span class="o">=</span> <span class="n">segment_asums</span> <span class="o">+</span> <span class="n">reach_cumsums</span> <span class="o">*</span>\
            <span class="n">convert_length_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry_length_units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">)</span>
        <span class="c1"># maintain positive asums; lengths in NHD often aren&#39;t exactly equal to feature lengths</span>
        <span class="c1"># reach_asums[reach_asums &lt; 0.] = 0</span>
        <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;asum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reach_asums</span>
            
        <span class="c1"># estimate widths if they aren&#39;t supplied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">width1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing widths...&quot;</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">width_from_arbolate_sum</span><span class="p">(</span><span class="n">reach_asums</span><span class="p">,</span>
                                            <span class="n">a</span><span class="o">=</span><span class="n">width_from_asum_a_param</span><span class="p">,</span>
                                            <span class="n">b</span><span class="o">=</span><span class="n">width_from_asum_b_param</span><span class="p">,</span>
                                            <span class="n">minimum_width</span><span class="o">=</span><span class="n">minimum_reach_width</span><span class="p">,</span>
                                            <span class="n">input_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">,</span> 
                                            <span class="n">output_units</span><span class="o">=</span><span class="n">model_length_units</span><span class="p">)</span>
            <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span>
            <span class="n">rd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rd</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">minimum_reach_width</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum_reach_width</span>

            <span class="c1"># assign width1 and width2 back to segment data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;width1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_from_arbolate_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">asum1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                            <span class="n">a</span><span class="o">=</span><span class="n">width_from_asum_a_param</span><span class="p">,</span>
                                            <span class="n">b</span><span class="o">=</span><span class="n">width_from_asum_b_param</span><span class="p">,</span>
                                            <span class="n">minimum_width</span><span class="o">=</span><span class="n">minimum_reach_width</span><span class="p">,</span>
                                            <span class="n">input_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">,</span>
                                            <span class="n">output_units</span><span class="o">=</span><span class="n">model_length_units</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;width2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_from_arbolate_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">asum2</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                        <span class="n">a</span><span class="o">=</span><span class="n">width_from_asum_a_param</span><span class="p">,</span>
                                                        <span class="n">b</span><span class="o">=</span><span class="n">width_from_asum_b_param</span><span class="p">,</span>
                                                        <span class="n">minimum_width</span><span class="o">=</span><span class="n">minimum_reach_width</span><span class="p">,</span>
                                                        <span class="n">input_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asum_units</span><span class="p">,</span>
                                                        <span class="n">output_units</span><span class="o">=</span><span class="n">model_length_units</span><span class="p">)</span>

        <span class="c1"># interpolate linestring end widths to intersected reaches</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># verify that each linestring has only 1 segment associated with it</span>
            <span class="c1"># (interpolation might be wrong for multiple segments otherwise)</span>
            <span class="k">assert</span> <span class="n">rd</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;line_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">iseg</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="c1"># sort the linestring and reach data so that they are aligned</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;line_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ireach&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_to_reaches</span><span class="p">(</span><span class="n">reach_data</span><span class="o">=</span><span class="n">rd</span><span class="p">,</span>
                                                 <span class="n">segment_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                                                 <span class="n">segvar1</span><span class="o">=</span><span class="s1">&#39;width1&#39;</span><span class="p">,</span> <span class="n">segvar2</span><span class="o">=</span><span class="s1">&#39;width2&#39;</span><span class="p">,</span>
                                                 <span class="n">reach_data_group_col</span><span class="o">=</span><span class="s1">&#39;line_id&#39;</span><span class="p">,</span>
                                                 <span class="n">segment_data_group_col</span><span class="o">=</span><span class="s1">&#39;id&#39;</span>
                                                 <span class="p">)</span> <span class="o">*</span> <span class="n">width_units_conversion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;width1&#39;</span><span class="p">,</span> <span class="s1">&#39;width2&#39;</span><span class="p">]]</span> <span class="o">*=</span> <span class="n">width_units_conversion</span>

        <span class="c1"># discard very small reaches; redo numbering</span>
        <span class="c1"># set minimum reach length based on cell size</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># fraction of cell length (based on square root of area)</span>
        <span class="k">if</span> <span class="n">minimum_reach_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cellgeoms</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rd</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            <span class="n">mean_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">cellgeoms</span><span class="p">])</span>
            <span class="n">minimum_reach_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">thresh</span> <span class="o">*</span> <span class="n">crs_units_conversion</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">rchlen</span> <span class="o">&gt;</span> <span class="n">minimum_reach_length</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Dropping </span><span class="si">{}</span><span class="s1"> reaches with length &lt; </span><span class="si">{:.2f}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">inds</span><span class="p">),</span>
                                                                        <span class="n">minimum_reach_length</span><span class="p">,</span>
                                                                        <span class="n">model_length_units</span><span class="p">))</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;strhc1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># default value of streambed Kv for now</span>
        <span class="c1"># handle co-located reaches</span>
        <span class="k">if</span> <span class="n">consolidate_conductance</span> <span class="ow">or</span> <span class="n">one_reach_per_cell</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">consolidate_reach_conductances</span><span class="p">(</span><span class="n">rd</span><span class="p">,</span> <span class="n">keep_only_dominant</span><span class="o">=</span><span class="n">one_reach_per_cell</span><span class="p">)</span>

        <span class="c1"># patch the routing</span>
        <span class="c1"># 1) reduce one to many routing to one-to-one routing (pick_toids() above)</span>
        <span class="c1"># 2) create new graph with just one-to-one segments</span>
        <span class="c1"># 3) list new paths;  2) and 3) should be automatic following 1)</span>
        <span class="c1"># 4) code below will update new graph to only include remaining segments</span>
        <span class="c1"># 5) create sfrdata instance; numbering will be messed up</span>
        <span class="c1"># 6) run methods on sfrdata instance to fix numbering and route reaches with unique numbers</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Repairing routing connections...&#39;</span><span class="p">)</span>
        <span class="n">remaining_ids</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="c1"># routing and paths properties should update automatically</span>
        <span class="c1"># when id and toid columns are changed in self.df</span>
        <span class="c1"># but only rd (reach_data) has been changed</span>
        <span class="n">new_routing</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># for each segment</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">remaining_ids</span><span class="p">:</span>
            <span class="c1"># interate through successive downstream segments</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># assign the first segment that still exists as the outseg</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">remaining_ids</span><span class="p">:</span>
                    <span class="n">new_routing</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">break</span>
            <span class="c1"># if no segments are left downstream, assign outlet</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_routing</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_routing</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># add any outlets to the stream network</span>
        <span class="c1"># for now handle int or str ids</span>
        <span class="k">if</span> <span class="n">add_outlets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get the</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add_outlets</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add_outlets</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">add_outlets</span> <span class="o">=</span> <span class="p">[</span><span class="n">add_outlets</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">outlet_id</span> <span class="ow">in</span> <span class="n">add_outlets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                    <span class="n">outlet_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">outlet_id</span><span class="p">)</span>
                    <span class="n">outlet_toid</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outlet_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">outlet_id</span><span class="p">)</span>
                    <span class="n">outlet_toid</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">valid_outlet_ids</span> <span class="o">=</span> <span class="n">get_previous_ids_in_subset</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="p">,</span> <span class="n">outlet_id</span><span class="p">)</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">valid_outlet_ids</span><span class="p">)</span>
                <span class="n">rd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="s1">&#39;toid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outlet_toid</span>
                <span class="k">for</span> <span class="n">valid_outlet_id</span> <span class="ow">in</span> <span class="n">valid_outlet_ids</span><span class="p">:</span>
                    <span class="n">new_routing</span><span class="p">[</span><span class="n">valid_outlet_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">outlet_toid</span>

        <span class="c1"># map remaining_ids to segment numbers</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">line_id</span><span class="p">,</span> <span class="n">rd</span><span class="o">.</span><span class="n">iseg</span><span class="p">))</span>
        <span class="n">line_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">lid</span> <span class="k">for</span> <span class="n">lid</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segment</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># get the segment associated with each line id</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="n">rid</span><span class="p">]</span> <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">remaining_ids</span><span class="p">]</span>
        <span class="c1"># get the segment associated with new connection for each line id</span>
        <span class="n">outseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_routing</span><span class="p">[</span><span class="n">line_id</span><span class="p">[</span><span class="n">s</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nseg</span><span class="p">]</span>

        <span class="c1"># renumber the segments to be consecutive,</span>
        <span class="c1"># starting at 1 and only increasing downstream</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">renumber_segments</span><span class="p">(</span><span class="n">nseg</span><span class="p">,</span> <span class="n">outseg</span><span class="p">)</span>
        <span class="c1"># map new segment numbers to line_ids</span>
        <span class="n">line_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span> <span class="n">lid</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lid</span> <span class="ow">in</span> <span class="n">line_id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># segment2 = {lid: r[s] for lid, s in segment.items()}</span>
        <span class="c1"># line_id2 = {s: lid for lid, s in segment2.items()}</span>

        <span class="c1"># update reach_data</span>
        <span class="n">rd</span><span class="p">[</span><span class="s1">&#39;iseg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">rd</span><span class="o">.</span><span class="n">iseg</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Setting up segment data...&#39;</span><span class="p">)</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;nseg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nseg</span><span class="p">]</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;outseg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">outseg</span><span class="p">]</span>
        <span class="n">sd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;nseg&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># verify that no segments route to themselves</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">routing_is_circular</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">outseg</span><span class="p">)</span>

        <span class="c1"># (elevup dict was created above)</span>
        <span class="n">elevup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevup</span>
        <span class="n">elevdn</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">elevdn</span><span class="p">))</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;elevup&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elevup</span><span class="p">[</span><span class="n">line_id</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sd</span><span class="o">.</span><span class="n">nseg</span><span class="p">]</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;elevdn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elevdn</span><span class="p">[</span><span class="n">line_id</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sd</span><span class="o">.</span><span class="n">nseg</span><span class="p">]</span>
        <span class="c1"># convert elevation units</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;elevup&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">elevation_units_conversion</span>
        <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;elevdn&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">elevation_units_conversion</span>

        <span class="c1"># apply widths if they were included</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;width1&#39;</span><span class="p">,</span> <span class="s1">&#39;width2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">width1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">width1</span><span class="p">))</span>
            <span class="n">width2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">width2</span><span class="p">))</span>
            <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;width1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">width1</span><span class="p">[</span><span class="n">line_id</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sd</span><span class="o">.</span><span class="n">nseg</span><span class="p">]</span>
            <span class="n">sd</span><span class="p">[</span><span class="s1">&#39;width2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">width2</span><span class="p">[</span><span class="n">line_id</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sd</span><span class="o">.</span><span class="n">nseg</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">width2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Need to supply width1 and width2 or use arbolate sum.&#39;</span><span class="p">)</span>

        <span class="c1"># create sfrdata instance</span>
        <span class="c1"># this class has methods for fix segment and reach numbering,</span>
        <span class="c1"># assigning elevations and other properties by reach,</span>
        <span class="c1"># smoothing elevations, writing sfr package files</span>
        <span class="c1"># and other output</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="n">rd</span><span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">SFRData</span><span class="o">.</span><span class="n">rdcols</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rd</span><span class="o">.</span><span class="n">columns</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sfrd</span> <span class="o">=</span> <span class="n">SFRData</span><span class="p">(</span><span class="n">reach_data</span><span class="o">=</span><span class="n">rd</span><span class="p">,</span> <span class="n">segment_data</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                       <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">model_length_units</span><span class="o">=</span><span class="n">model_length_units</span><span class="p">,</span>
                       <span class="n">model_time_units</span><span class="o">=</span><span class="n">model_time_units</span><span class="p">,</span>
                       <span class="n">package_name</span><span class="o">=</span><span class="n">package_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Time to create sfr dataset: </span><span class="si">{:.2f}</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">totim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sfrd</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
      <span class="lastupdated">Last updated on Jan 15, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>